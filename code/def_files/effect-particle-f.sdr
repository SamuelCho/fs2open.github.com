uniform sampler2D baseMap;
uniform sampler2D depthMap;
uniform float window_width;
uniform float window_height;
uniform float nearZ;
uniform float farZ;
uniform int linear_depth;
uniform int srgb;
uniform int blend_alpha;
uniform int sphere;
in float fragRadius;
in vec4 fragPosition;
in vec4 fragTexCoord;
in vec4 fragColor;
out vec4 fragOut0;
#define SRGB_GAMMA 2.2
#define EMISSIVE_GAIN 2.0
void main()
{
	vec4 fragmentColor = texture(baseMap, fragTexCoord.xy);
	fragmentColor.rgb = mix(fragmentColor.rgb, pow(fragmentColor.rgb, vec3(SRGB_GAMMA)), float(srgb));
	fragmentColor *= mix(fragColor, vec4(pow(fragColor.rgb, vec3(SRGB_GAMMA)), fragColor.a), float(srgb));

	vec2 depthCoord = vec2(gl_FragCoord.x / window_width, gl_FragCoord.y / window_height );
	vec4 sceneDepth = texture(depthMap, depthCoord);

	float sceneDepthLinear;
	float fragDepthLinear;

	if ( linear_depth == 1 ) {
		sceneDepthLinear = -sceneDepth.z;
		fragDepthLinear = -fragPosition.z;
	} else {
		sceneDepthLinear = ( 2.0 * farZ * nearZ ) / ( farZ + nearZ - sceneDepth.x * (farZ-nearZ) );
		fragDepthLinear = ( 2.0 * farZ * nearZ ) / ( farZ + nearZ - gl_FragCoord.z * (farZ-nearZ) );
	}

	float depthOffset = fragRadius;

	if ( sphere == 1 ) {
		// assume UV of 0.5, 0.5 is the centroid of this sphere volume
		vec2 offset = vec2(fragRadius * abs(0.5 - fragTexCoord.x) * 2.0, fragRadius * abs(0.5 - fragTexCoord.y) * 2.0);
		float offset_len = length(offset);
		depthOffset = sqrt(pow(fragRadius, 2.0) - pow(offset_len, 2.0));
		fragmentColor = (offset_len > fragRadius) ? vec4(0.0, 0.0, 0.0, 0.0) : fragmentColor;
	}
	
	float frontDepth = fragDepthLinear - depthOffset;
	float backDepth = fragDepthLinear + depthOffset;
	float intensity = smoothstep(max(nearZ, frontDepth), backDepth, sceneDepthLinear);

	fragmentColor.rgb *= (srgb == 1) ? EMISSIVE_GAIN : 1.0;
	fragmentColor = (blend_alpha == 1) ? vec4(fragmentColor.rgb, fragmentColor.a * intensity) : vec4(fragmentColor.rgb * intensity, fragmentColor.a);

	fragOut0 = max(fragmentColor, vec4(0.0));
}